# 5장 좋은 테스트의 FIRST 속성

## FIRST : 좋은 테스트 조건
- FIRST 의 원리를 따르면 단위 테스트 작성자가 흔히 빠지는 위험을 피할수 있다.
  - **F**ast : 빠른
  - **I**solated : 고립된
  - **R**epeatable : 반복가능한
  - **S**elf-validating : 스스로 검증가능한
  - **T**imely : 적시의
- FIRST 는 단어 그 자체로 테스트 맥락에서 상당한 의미가 있다.

## [F]IRST : 빠르다
- 빠른 테스트와 느린 테스트의 구분선은 다소 자의적
- 빠른 테스트는 **코드만 실행** 하며 수 밀리초 수준이고, 느린 테스트는 디비와 같이 **외부 자원을 다루는 코드를 호출** 하며 수백 수천 밀리초가 걸리기도 한다.
- 단위테스트가 많아 질수록 이 차이는 극심해진다.
- 테스트를 빠르게 유지하라.
- 설계를 깨끗히 하면 빠르게 유지할 수 있다.
- 가장 먼저 느린 테스트에 대한 의존성을 줄여야 한다.
- 코드를 객체지향 설계 원칙에 맞출수록 단위 테스트 작성도 쉬워진다.
  - 테스트하기 쉬운 코드 => 좋은 설계일 확률이 높다.

## F[I]RST : 고립시킨다
- 좋은 단 테스트는 검증하려는 적은 양의 코드에 집중한다.
- 테스트 코드와 상호작용하는 코드가 많아질수록 문제가 발생할 소지는 증가한다.
- 데이터 의존성은 많은 문제를 야기한다.
- 디비에 의존하는 테스트는, 데이터가 올바른지에 대한 검증도 필요하다.
- 또한 데이터 소스를 공유한다면 테스트를 깨트리는 외부 변화도 신경써야 한다.
  - 동시에 여럿이 테스트를 돌린다면 테스트가 실패할 수도 있다.
- 단순히 외부 저장소와 상호작용 한다면 테스트가 가용성 혹은 접근성 이슈로 실패할 가능성이 크다.
- 좋은 단위 테스트는 **다른 단위테스트에 의존 하지 않는다.**
- 테스트 코드는 순서나 시간에 관계없이 실행할 수 있어야 한다.
- 단일 책임원칙에 따르면 클래스는 작고 단잃나 목적을 가져야 한다.
  - 클래스를 변경해야할 이유는 하나만 있어야 한다.
- 테스트 메소드에도 적용이 가능하다.
- 테스트 메소드가 하나 이상의 이유로 깨진다면, 테스트 분할을 고려해야 한다.

## FI[R]ST : 좋은 테스트는 반복 가능해야 한다
- 테스트 설계에서 우리가 해야할 일은, 테스트 결과가 매번 어떻게 나와야하는지에 대한 **단언** 을 작성해야 한다.
- 반복가능한 테스트는 실행마다 결과가 동일해야 한다.
- 즉 통제 할 수 없는 환경과 격리시켜야 한다.
- 예를 들어 시간을 다뤄야 한다면, 테스트 코드는 반복 가능한 테스트를 힘들게하는 요ㅛ소를 다르게 된다.
- 시간은 우리가 직접 통제할 수 없기 때문에 이를 단언하는 것은 매우 힘든일이다.
- 종종 실패하는 코드는 **양치기 소년** 이 될 수 있다.
- 이런 테스트는 나쁜 테스트이다.
- Java8 에서는 java.time.Clock 객체를 활용해 고정된 시간을 반환할 수 있다.
- 이를 활용해 시간을 제어할 수 있다.
  - DI 원칙을 준수한 설계
  - 테스트 더블

## FIR[S]T : 스스로 검증 가능하다
- 테스트는 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아니다.
- 단위 테스트는 시간을 소모하기 보다 절약한다.
- 테스트 결과를 수정으로 검증하는 것은 시간 소모적인 절차고 리스크가 늘어난다.
- 테스트는 스스로 검증 가능할 뿐 아니라 준비도 할 수 있어야 한다.
  - 테스트 실행전 수동으로 준비단계를 만드는 행동은 하지 말아야 한다.
  - 설정 단계는 반드시 자동화 해야 한다.
- 젠킨스나 TeamCity 같은 지속적인 통합 (CI) 도구를 사용할 수 있다.

## FIRS[T] : 적시에 사용한다
- 단위 테스트를 많이 할수록 테스트 대상 코드가 줄어든다.
- 그러면 먼저 단위 테스트 작성이 쉬워진다.
- 옛날 코드에 대한 테스트는 시간 낭비가 될 수도 있다.
- 코드에 큰 결함이 없고 당장 변경할 예정이 없다면 좀 더 역동적인 부분에 투자하라.